{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HPC - Numpy Utility Package","text":""},{"location":"#overview","title":"Overview","text":"<p>HPC is a numpy utility package focused on high-performance computing applications. It provides efficient functions for indexing and manipulating numpy arrays without using loops, resulting in faster execution times.</p>"},{"location":"#main-features","title":"Main Features","text":"<ul> <li>Fast indexing of numpy arrays without using loops</li> <li>Efficient pixel extraction from arrays with optional masking</li> <li>Location of values in grids with coordinate mapping</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import numpy as np\nimport hpc\n\n# Create a sample array\narr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n# Get indices of all non-zero values\ni, j = hpc.get_indices(arr, None)\nprint(f\"Row indices: {i}\")\nprint(f\"Column indices: {j}\")\n\n# Get indices of specific value\ni, j = hpc.get_indices(arr, 5)\nprint(f\"Row indices for value 5: {i}\")\nprint(f\"Column indices for value 5: {j}\")\n\n# Get pixels with masking\nmask = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\npixels = hpc.get_pixels(arr, mask)\nprint(f\"Masked pixels: {pixels}\")\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>For installation instructions, see the Installation page.</p>"},{"location":"#api-documentation","title":"API Documentation","text":"<p>For detailed API documentation, see the API Documentation section.</p> <p>Note</p> <p>This documentation was generated on 2025-07-24.</p>"},{"location":"change-log/","title":"Change Log","text":""},{"location":"change-log/#015-2025-07-24","title":"0.1.5 (2025-07-24)","text":""},{"location":"change-log/#dev","title":"Dev","text":"<ul> <li>Improved documentation with Google style docstrings</li> <li>Added more comprehensive examples to all functions</li> <li>Updated mkdocs configuration to use Google style docstrings</li> </ul>"},{"location":"change-log/#014-2024-06-24","title":"0.1.4 (2024-06-24)","text":""},{"location":"change-log/#changed","title":"Changed","text":"<ul> <li>Update dependencies</li> </ul>"},{"location":"change-log/#013-2023-10-31","title":"0.1.3 (2023-10-31)","text":""},{"location":"change-log/#changed_1","title":"Changed","text":"<ul> <li>Update dependencies</li> </ul>"},{"location":"change-log/#012-2023-08-30","title":"0.1.2 (2023-08-30)","text":""},{"location":"change-log/#changed_2","title":"Changed","text":"<ul> <li>Update dependencies</li> </ul>"},{"location":"change-log/#011-2023-04-23","title":"0.1.1 (2023-04-23)","text":""},{"location":"change-log/#added","title":"Added","text":"<ul> <li>get_pixels works with 3d arrays</li> </ul>"},{"location":"change-log/#010-2023-03-30","title":"0.1.0 (2023-03-30)","text":""},{"location":"change-log/#added_1","title":"Added","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#dependencies","title":"Dependencies","text":""},{"location":"installation/#required-dependencies","title":"Required dependencies","text":"<ul> <li>Python (3.11 or later)</li> <li>numpy (2.0.0 or later)</li> </ul>"},{"location":"installation/#optional-dependencies","title":"Optional dependencies","text":""},{"location":"installation/#development-dependencies","title":"Development dependencies","text":"<ul> <li>nbval (0.11.0 or later)</li> <li>pre-commit (3.7.1 or later)</li> <li>pre-commit-hooks (4.6.0 or later)</li> <li>pytest (8.2.2 or later)</li> <li>pytest-cov (5.0.0 or later)</li> <li>coverage</li> </ul>"},{"location":"installation/#documentation-dependencies","title":"Documentation dependencies","text":"<ul> <li>mkdocs (1.5.3 or later)</li> <li>mkdocs-material (9.5.3 or later)</li> <li>mkdocstrings (0.24.0 or later)</li> <li>mkdocstrings-python (1.7.5 or later)</li> <li>mike (2.1.3 or later)</li> <li>mkdocs-jupyter (0.25.1 or later)</li> <li>mkdocs-autorefs (1.2 or later)</li> <li>mkdocs-macros-plugin (1.3.7 or later)</li> <li>mkdocs-table-reader-plugin (3.1.0 or later)</li> <li>mkdocs-mermaid2-plugin (1.2.1 or later)</li> <li>jupyter-contrib-nbextensions (0.7.0 or later)</li> <li>notebook (&lt; 7.0)</li> <li>jupyter</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":"<p>Please install <code>hpc</code> in a virtual environment so that its requirements don't tamper with your system's Python.</p>"},{"location":"installation/#using-pixi-recommended","title":"Using Pixi (Recommended)","text":"<p>Pixi is a package manager and environment manager developed by Prefix.dev. It's designed to create reproducible environments and is used in this project for dependency management.</p>"},{"location":"installation/#installing-pixi","title":"Installing Pixi","text":"<p>If you don't have Pixi installed, you can install it following the instructions on the Pixi installation page.</p> <p>For Windows: <pre><code># Using PowerShell\niwr -useb https://pixi.sh/install.ps1 | iex\n</code></pre></p> <p>For Linux/macOS: <pre><code># Using curl\ncurl -fsSL https://pixi.sh/install.sh | bash\n</code></pre></p>"},{"location":"installation/#setting-up-the-environment-with-pixi","title":"Setting up the environment with Pixi","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/Serapieum-of-alex/hpc.git\ncd hpc\n</code></pre></p> </li> <li> <p>Install dependencies using Pixi: <pre><code>pixi install\n</code></pre></p> </li> </ol> <p>This will create a reproducible environment with all the required dependencies based on the pixi.lock file.</p>"},{"location":"installation/#using-different-environments","title":"Using different environments","text":"<p>The project defines three environments in the pyproject.toml file:</p> <ol> <li> <p>default: Basic environment with minimal dependencies <pre><code># Activate the default environment\npixi shell\n</code></pre></p> </li> <li> <p>dev: Development environment with testing tools <pre><code># Run a command in the dev environment\npixi run --environment dev pytest\n</code></pre></p> </li> <li> <p>docs: Documentation environment with tools for building docs <pre><code># Run a command in the docs environment\npixi run --environment docs mkdocs build\n</code></pre></p> </li> </ol>"},{"location":"installation/#using-conda","title":"Using Conda","text":"<p>The easiest way to install <code>hpc</code> is using the <code>conda</code> package manager. <code>hpc</code> is available in the conda-forge channel. To install you can use the following command:</p> <pre><code>conda install -c conda-forge hpc\n</code></pre> <p>If this works it will install <code>hpc</code> with all dependencies including Python, and you can skip the rest of the installation instructions.</p>"},{"location":"installation/#using-pip-pypi","title":"Using Pip (PyPI)","text":"<p>To install the latest release of <code>hpc</code> from PyPI:</p> <pre><code>pip install hpc-utils\n</code></pre> <p>To install a specific version:</p> <pre><code>pip install hpc-utils==0.1.4\n</code></pre>"},{"location":"installation/#installing-python","title":"Installing Python","text":"<p>For Python, we recommend using the Anaconda Distribution for Python 3, which is available for download from https://www.anaconda.com/download/. The installer gives the option to add <code>python</code> to your <code>PATH</code> environment variable. We will assume in the instructions below that it is available in the path, such that <code>python</code>, <code>pip</code>, and <code>conda</code> are all available from the command line.</p> <p>Note that there is no hard requirement specifically for Anaconda's Python, but often it makes installation of required dependencies easier using the conda package manager.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>The sources for <code>hpc</code> can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/Serapieum-of-alex/hpc\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/Serapieum-of-alex/hpc/tarball/main\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>python -m pip install .\n</code></pre> <p>To install directly from GitHub (from the HEAD of the main branch):</p> <pre><code>pip install git+https://github.com/Serapieum-of-alex/hpc.git\n</code></pre> <p>or from Github from a specific release:</p> <pre><code>pip install git+https://github.com/Serapieum-of-alex/hpc.git@{release}\n</code></pre> <p>If you are planning to make changes and contribute to the development of <code>hpc</code>, it is best to make a git clone of the repository, and do an editable install in the location of your clone. This will not move a copy to your Python installation directory, but instead create a link in your Python installation pointing to the folder you installed it from, such that any changes you make there are directly reflected in your install.</p> <pre><code>git clone https://github.com/Serapieum-of-alex/hpc.git\ncd hpc\npip install -e .\n</code></pre>"},{"location":"installation/#check-if-the-installation-is-successful","title":"Check if the installation is successful","text":"<p>To check if the install is successful, try importing the package:</p> <pre><code>import hpc\nprint(hpc.__version__)\n</code></pre> <p>This should run without errors and display the version number.</p> <p>Note</p> <p>This documentation was generated on 2025-07-24</p> <p>Documentation for the development version: https://hpc.readthedocs.org/en/latest/</p> <p>Documentation for the stable version: https://hpc.readthedocs.org/en/stable/</p>"},{"location":"pre-commit/","title":"Pre-commit Hooks with Pixi","text":""},{"location":"pre-commit/#overview","title":"Overview","text":"<p>Pre-commit hooks are scripts that run automatically before each commit to identify and fix common issues early in the development process. This project uses pre-commit to manage these hooks, ensuring code quality and consistency.</p> <p>When integrated with Pixi, pre-commit hooks can be easily managed within your project's development environment.</p>"},{"location":"pre-commit/#benefits-of-pre-commit-hooks","title":"Benefits of Pre-commit Hooks","text":"<ul> <li>Catch issues early: Identify problems before they're committed</li> <li>Consistent code style: Automatically format code to project standards</li> <li>Prevent security issues: Detect secrets, vulnerabilities, and other security concerns</li> <li>Save time: Avoid failed CI/CD pipelines by catching issues locally</li> <li>Improve code quality: Run tests and linters automatically</li> </ul>"},{"location":"pre-commit/#setting-up-pre-commit-with-pixi","title":"Setting Up Pre-commit with Pixi","text":""},{"location":"pre-commit/#1-install-pixi","title":"1. Install Pixi","text":"<p>If you haven't installed Pixi yet, follow the instructions on the Pixi installation page:</p> <p>For Windows: <pre><code># Using PowerShell\niwr -useb https://pixi.sh/install.ps1 | iex\n</code></pre></p> <p>For Linux/macOS: <pre><code># Using curl\ncurl -fsSL https://pixi.sh/install.sh | bash\n</code></pre></p>"},{"location":"pre-commit/#2-clone-the-repository-and-install-dependencies","title":"2. Clone the Repository and Install Dependencies","text":"<pre><code>git clone https://github.com/Serapieum-of-alex/hpc.git\ncd hpc\npixi install\n</code></pre>"},{"location":"pre-commit/#3-install-pre-commit-in-the-pixi-environment","title":"3. Install Pre-commit in the Pixi Environment","text":"<p>The project already has pre-commit as a development dependency in the <code>pyproject.toml</code> file. When you run <code>pixi install</code>, pre-commit will be installed in the development environment.</p> <p>To verify that pre-commit is installed:</p> <pre><code>pixi run --environment dev pre-commit --version\n</code></pre>"},{"location":"pre-commit/#4-install-the-pre-commit-hooks","title":"4. Install the Pre-commit Hooks","text":"<p>To install the pre-commit hooks into your local git repository:</p> <pre><code>pixi run --environment dev pre-commit install\n</code></pre> <p>This will set up the git hooks script and also install the hook environments.</p> <p>To install the commit message hook:</p> <pre><code>pixi run --environment dev pre-commit install --hook-type commit-msg\n</code></pre>"},{"location":"pre-commit/#using-pre-commit-hooks","title":"Using Pre-commit Hooks","text":""},{"location":"pre-commit/#running-pre-commit-hooks-manually","title":"Running Pre-commit Hooks Manually","text":"<p>To run all pre-commit hooks manually on all files:</p> <pre><code>pixi run --environment dev pre-commit run --all-files\n</code></pre> <p>To run a specific hook:</p> <pre><code>pixi run --environment dev pre-commit run &lt;hook-id&gt; --all-files\n</code></pre> <p>For example, to run just the black formatter:</p> <pre><code>pixi run --environment dev pre-commit run black --all-files\n</code></pre>"},{"location":"pre-commit/#automatic-execution","title":"Automatic Execution","text":"<p>Once installed, pre-commit hooks will run automatically when you attempt to commit changes. If any hook fails, the commit will be aborted, allowing you to fix the issues before trying again.</p>"},{"location":"pre-commit/#skipping-hooks","title":"Skipping Hooks","text":"<p>In some cases, you might need to skip pre-commit hooks:</p> <pre><code>git commit -m \"Your message\" --no-verify\n</code></pre> <p>However, this should be used sparingly, as the hooks are designed to maintain code quality.</p>"},{"location":"pre-commit/#configured-hooks","title":"Configured Hooks","text":"<p>This project has the following pre-commit hooks configured:</p>"},{"location":"pre-commit/#code-formatting","title":"Code Formatting","text":"<ul> <li>black: Python code formatter</li> <li>isort: Sorts Python imports</li> <li>beautysh: Shell script formatter</li> </ul>"},{"location":"pre-commit/#code-quality","title":"Code Quality","text":"<ul> <li>flake8: Python linter</li> <li>bandit: Security linter for Python code</li> </ul>"},{"location":"pre-commit/#file-formatting","title":"File Formatting","text":"<ul> <li>trailing-whitespace: Removes trailing whitespace</li> <li>end-of-file-fixer: Ensures files end with a newline</li> <li>mixed-line-ending: Normalizes line endings</li> <li>pretty-format-json: Formats JSON files</li> </ul>"},{"location":"pre-commit/#security-checks","title":"Security Checks","text":"<ul> <li>gitleaks: Scans for secrets and credentials</li> <li>detect-secrets: Detects secrets in code</li> <li>checkov: Scans for security issues</li> <li>truffleHog: Finds credentials and secrets</li> </ul>"},{"location":"pre-commit/#testing","title":"Testing","text":"<ul> <li>pytest-check: Runs pytest with coverage</li> <li>notebook-check: Validates Jupyter notebooks</li> <li>doctest: Runs doctests in Python modules</li> </ul>"},{"location":"pre-commit/#customizing-pre-commit-configuration","title":"Customizing Pre-commit Configuration","text":"<p>The pre-commit configuration is stored in the <code>.pre-commit-config.yaml</code> file at the root of the repository. You can modify this file to add, remove, or configure hooks.</p> <p>After modifying the configuration, update the installed hooks:</p> <pre><code>pixi run --environment dev pre-commit install\n</code></pre>"},{"location":"pre-commit/#troubleshooting","title":"Troubleshooting","text":""},{"location":"pre-commit/#hook-installation-issues","title":"Hook Installation Issues","text":"<p>If you encounter issues installing hooks:</p> <pre><code>pixi run --environment dev pre-commit clean\npixi run --environment dev pre-commit install\n</code></pre>"},{"location":"pre-commit/#slow-hooks","title":"Slow Hooks","text":"<p>Some hooks, particularly those that run tests, can be slow. You can skip these during development:</p> <pre><code>SKIP=pytest-check,notebook-check git commit -m \"Your message\"\n</code></pre>"},{"location":"pre-commit/#updating-hooks","title":"Updating Hooks","text":"<p>To update all hooks to their latest versions:</p> <pre><code>pixi run --environment dev pre-commit autoupdate\n</code></pre>"},{"location":"pre-commit/#best-practices","title":"Best Practices","text":"<ol> <li>Run hooks before pushing: Ensure all hooks pass before pushing to remote</li> <li>Keep hooks updated: Regularly run <code>pre-commit autoupdate</code></li> <li>Add custom hooks: Create local hooks for project-specific checks</li> <li>Document hook behavior: Ensure team members understand what each hook does</li> <li>Use with CI/CD: Run the same checks in your CI/CD pipeline</li> </ol> <p>Note</p> <p>This documentation was generated on 2025-07-24.</p>"},{"location":"api/indexing/","title":"Indexing Module","text":"<p>The indexing module provides efficient functions for working with numpy arrays, particularly for indexing and extracting values based on various conditions.</p>"},{"location":"api/indexing/#functions","title":"Functions","text":""},{"location":"api/indexing/#hpc.indexing.get_indices","title":"<code>get_indices(arr, mask_val)</code>","text":"<p>Get the array indices for the non-zero cells.</p> <p>This function returns the row and column indices of cells in a 2D array that match a specific value or all non-zero values.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>2D array with values you need to get the indexes of the cells that are filled with these values.</p> required <code>mask_val</code> <code>Union[int, float]</code> <p>If you need to locate only a certain value, and not all values in the array. If None or falsy, will return indices of all non-zero values.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>A tuple of two numpy arrays: - first array is the row indices - second array is the column indices</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input array is not 2D.</p> <p>Examples:</p> <ul> <li>Import numpy <pre><code>&gt;&gt;&gt; import numpy as np\n</code></pre></li> <li>Create a sample array <pre><code>&gt;&gt;&gt; arr = np.array([[0, 1, 0], [0, 0, 2], [3, 0, 0]])\n</code></pre></li> <li>Get indices of all non-zero values <pre><code>&gt;&gt;&gt; i, j = get_indices(arr, None)\n&gt;&gt;&gt; print(i)\n[0 1 2]\n&gt;&gt;&gt; print(j)\n[1 2 0]\n</code></pre></li> <li>Get indices of a specific value <pre><code>&gt;&gt;&gt; i, j = get_indices(arr, 2)\n&gt;&gt;&gt; print(i)\n[1]\n&gt;&gt;&gt; print(j)\n[2]\n</code></pre></li> </ul> Source code in <code>src/hpc/indexing.py</code> <pre><code>def get_indices(\n    arr: np.ndarray, mask_val: Union[int, float]\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Get the array indices for the non-zero cells.\n\n    This function returns the row and column indices of cells in a 2D array that match\n    a specific value or all non-zero values.\n\n    Args:\n        arr: 2D array with values you need to get the indexes of the cells that are filled with these values.\n        mask_val: If you need to locate only a certain value, and not all values in the array.\n            If None or falsy, will return indices of all non-zero values.\n\n    Returns:\n        A tuple of two numpy arrays:\n            - first array is the row indices\n            - second array is the column indices\n\n    Raises:\n        ValueError: If the input array is not 2D.\n\n    Examples:\n        - Import numpy\n        ```python\n        &gt;&gt;&gt; import numpy as np\n\n        ```\n        - Create a sample array\n        ```python\n        &gt;&gt;&gt; arr = np.array([[0, 1, 0], [0, 0, 2], [3, 0, 0]])\n\n        ```\n        - Get indices of all non-zero values\n        ```python\n        &gt;&gt;&gt; i, j = get_indices(arr, None)\n        &gt;&gt;&gt; print(i)\n        [0 1 2]\n        &gt;&gt;&gt; print(j)\n        [1 2 0]\n\n        ```\n        - Get indices of a specific value\n        ```python\n        &gt;&gt;&gt; i, j = get_indices(arr, 2)\n        &gt;&gt;&gt; print(i)\n        [1]\n        &gt;&gt;&gt; print(j)\n        [2]\n\n        ```\n    \"\"\"\n    # Use the arr to get the indices of the non-zero pixels.\n    if mask_val is not None:\n        (i, j) = (arr == mask_val).nonzero()\n    else:\n        (i, j) = arr.nonzero()\n\n    return i, j\n</code></pre>"},{"location":"api/indexing/#hpc.indexing.get_indices2","title":"<code>get_indices2(arr, mask=None)</code>","text":"<p>Get indices of array cells after filtering values based on mask values.</p> <p>This function returns the indices of array cells that don't match the values in the mask. If mask is None, returns indices of all cells in the array. This function is particularly useful for filtering out specific values (like NoData values) from an array.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>2D numpy array to get indices from.</p> required <code>mask</code> <code>Optional[List[Union[int, float, number]]]</code> <p>List of values to exclude from the result. - If None, returns indices of all cells. - If list with one value, returns indices of cells not equal to that value. - If list with two values, returns indices of cells not equal to either value.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Tuple[int, int]]</code> <p>List of tuples (row, col) representing the indices of cells that pass the filter.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mask contains more than two values.</p> <code>ValueError</code> <p>If the input array is not 2D.</p> <p>Examples:</p> <ul> <li>Import numpy <pre><code>&gt;&gt;&gt; import numpy as np\n</code></pre></li> <li>Create a sample array <pre><code>&gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n</code></pre></li> <li>Get all indices <pre><code>&gt;&gt;&gt; indices = get_indices2(arr, None)\n&gt;&gt;&gt; len(indices)  # 3x3 array = 9 indices\n9\n</code></pre></li> <li>Filter out cells with value 5 <pre><code>&gt;&gt;&gt; indices = get_indices2(arr, [5])\n&gt;&gt;&gt; sorted(indices) #doctest: +SKIP\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]\n</code></pre></li> <li>Filter out cells with values 1 and 9 <pre><code>&gt;&gt;&gt; indices = get_indices2(arr, [1, 9])\n&gt;&gt;&gt; sorted(indices)     #doctest: +SKIP\n[(0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1)]\n</code></pre></li> <li>Works with NaN values <pre><code>&gt;&gt;&gt; arr_with_nan = np.array([[1, 2, np.nan], [4, 5, 6]])\n&gt;&gt;&gt; indices = get_indices2(arr_with_nan, [np.nan])\n&gt;&gt;&gt; sorted(indices) #doctest: +SKIP\n[(0, 0), (0, 1), (1, 0), (1, 1), (1, 2)]\n</code></pre></li> </ul> Source code in <code>src/hpc/indexing.py</code> <pre><code>def get_indices2(\n    arr: np.ndarray, mask: Optional[List[Union[int, float, np.number]]] = None\n) -&gt; List[Tuple[int, int]]:\n    \"\"\"Get indices of array cells after filtering values based on mask values.\n\n    This function returns the indices of array cells that don't match the values in the mask.\n    If mask is None, returns indices of all cells in the array. This function is particularly\n    useful for filtering out specific values (like NoData values) from an array.\n\n    Args:\n        arr: 2D numpy array to get indices from.\n        mask: List of values to exclude from the result.\n            - If None, returns indices of all cells.\n            - If list with one value, returns indices of cells not equal to that value.\n            - If list with two values, returns indices of cells not equal to either value.\n\n    Returns:\n        List of tuples (row, col) representing the indices of cells that pass the filter.\n\n    Raises:\n        ValueError: If mask contains more than two values.\n        ValueError: If the input array is not 2D.\n\n    Examples:\n        - Import numpy\n        ```python\n        &gt;&gt;&gt; import numpy as np\n\n        ```\n        - Create a sample array\n        ```python\n        &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        ```\n        - Get all indices\n        ```python\n        &gt;&gt;&gt; indices = get_indices2(arr, None)\n        &gt;&gt;&gt; len(indices)  # 3x3 array = 9 indices\n        9\n\n        ```\n        - Filter out cells with value 5\n        ```python\n        &gt;&gt;&gt; indices = get_indices2(arr, [5])\n        &gt;&gt;&gt; sorted(indices) #doctest: +SKIP\n        [(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]\n\n        ```\n        - Filter out cells with values 1 and 9\n        ```python\n        &gt;&gt;&gt; indices = get_indices2(arr, [1, 9])\n        &gt;&gt;&gt; sorted(indices)     #doctest: +SKIP\n        [(0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1)]\n\n        ```\n        - Works with NaN values\n        ```python\n        &gt;&gt;&gt; arr_with_nan = np.array([[1, 2, np.nan], [4, 5, 6]])\n        &gt;&gt;&gt; indices = get_indices2(arr_with_nan, [np.nan])\n        &gt;&gt;&gt; sorted(indices) #doctest: +SKIP\n        [(0, 0), (0, 1), (1, 0), (1, 1), (1, 2)]\n\n        ```\n    \"\"\"\n    # get the position of cells that is not zeros\n    if mask is not None:\n        if len(mask) &gt; 1:\n            mask = np.logical_and(\n                ~np.isclose(arr, mask[0], rtol=0.001),\n                ~np.isclose(arr, mask[1], rtol=0.001),\n            )\n        else:\n            if np.isnan(mask[0]):\n                mask = ~np.isnan(arr)\n            else:\n                mask = ~np.isclose(arr, mask[0], rtol=0.001)\n\n        rows = np.nonzero(mask)[0]\n        cols = np.nonzero(mask)[1]\n\n        ind = list(zip(rows, cols))\n    else:\n        rows = arr.shape[0]\n        cols = arr.shape[1]\n        ind = [(i, j) for i in range(rows) for j in range(cols)]\n\n    return ind\n</code></pre>"},{"location":"api/indexing/#hpc.indexing.get_pixels","title":"<code>get_pixels(arr, mask=None, mask_val=None)</code>","text":"<p>Get pixels from a raster (with optional mask).</p> <p>This function extracts pixel values from an array based on a mask. It can work with both 2D and 3D arrays and can extract pixels based on specific mask values.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>Array of raster data in the form [bands][y][x] or [y][x].</p> required <code>mask</code> <code>ndarray</code> <p>Array (2D) of values to mask data (from rasterizing a vector). If None, returns the original array.</p> <code>None</code> <code>mask_val</code> <code>Union[int, float, None]</code> <p>Value of the data pixels in the mask to extract. If None or falsy, will extract all non-zero values.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array of non-masked data. - For 2D input: 1D array of values - For 3D input: 2D array with bands as rows and filtered pixels as columns</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the mask dimensions don't match the array dimensions.</p> <p>Examples:</p> <ul> <li>Import numpy <pre><code>&gt;&gt;&gt; import numpy as np\n</code></pre></li> <li>2D array example <pre><code>&gt;&gt;&gt; arr_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; mask = np.array([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\n&gt;&gt;&gt; get_pixels(arr_2d, mask)\narray([2, 6])\n</code></pre></li> <li>3D array example <pre><code>&gt;&gt;&gt; arr_3d = np.array([[[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n...                    [[10, 20, 30], [40, 50, 60], [70, 80, 90]]])\n&gt;&gt;&gt; get_pixels(arr_3d, mask)\narray([[ 2,  6],\n       [20, 60]])\n</code></pre></li> <li>With specific mask value <pre><code>&gt;&gt;&gt; mask2 = np.array([[0, 2, 0], [0, 0, 2], [0, 0, 0]])\n&gt;&gt;&gt; get_pixels(arr_2d, mask2, 2)\narray([2, 6])\n</code></pre></li> </ul> Source code in <code>src/hpc/indexing.py</code> <pre><code>def get_pixels(\n    arr: np.ndarray, mask: np.ndarray = None, mask_val: Union[int, float, None] = None\n) -&gt; np.ndarray:\n    \"\"\"Get pixels from a raster (with optional mask).\n\n    This function extracts pixel values from an array based on a mask. It can work with\n    both 2D and 3D arrays and can extract pixels based on specific mask values.\n\n    Args:\n        arr: Array of raster data in the form [bands][y][x] or [y][x].\n        mask: Array (2D) of values to mask data (from rasterizing a vector).\n            If None, returns the original array.\n        mask_val: Value of the data pixels in the mask to extract.\n            If None or falsy, will extract all non-zero values.\n\n    Returns:\n        np.ndarray: Array of non-masked data.\n            - For 2D input: 1D array of values\n            - For 3D input: 2D array with bands as rows and filtered pixels as columns\n\n    Raises:\n        ValueError: If the mask dimensions don't match the array dimensions.\n\n    Examples:\n        - Import numpy\n        ```python\n        &gt;&gt;&gt; import numpy as np\n\n        ```\n        - 2D array example\n        ```python\n        &gt;&gt;&gt; arr_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        &gt;&gt;&gt; mask = np.array([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\n        &gt;&gt;&gt; get_pixels(arr_2d, mask)\n        array([2, 6])\n\n        ```\n        - 3D array example\n        ```python\n        &gt;&gt;&gt; arr_3d = np.array([[[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n        ...                    [[10, 20, 30], [40, 50, 60], [70, 80, 90]]])\n        &gt;&gt;&gt; get_pixels(arr_3d, mask)\n        array([[ 2,  6],\n               [20, 60]])\n\n        ```\n        - With specific mask value\n        ```python\n        &gt;&gt;&gt; mask2 = np.array([[0, 2, 0], [0, 0, 2], [0, 0, 0]])\n        &gt;&gt;&gt; get_pixels(arr_2d, mask2, 2)\n        array([2, 6])\n\n        ```\n    \"\"\"\n    if mask is None:\n        return arr\n\n    # Validate that mask dimensions match array dimensions\n    if arr.ndim == 2:\n        if mask.shape != arr.shape:\n            raise ValueError(\n                f\"Mask shape {mask.shape} does not match array shape {arr.shape}\"\n            )\n    elif arr.ndim == 3:\n        if mask.shape != arr.shape[1:]:\n            raise ValueError(\n                f\"Mask shape {mask.shape} does not match array shape {arr.shape[1:]}\"\n            )\n    else:\n        raise ValueError(f\"Unsupported array dimensions: {arr.ndim}\")\n\n    i, j = get_indices(mask, mask_val)\n    # get the corresponding values to the indices from the array\n    vals = arr[i, j] if arr.ndim == 2 else arr[:, i, j]\n    return vals\n</code></pre>"},{"location":"api/indexing/#hpc.indexing.get_pixels2","title":"<code>get_pixels2(arr, mask=None)</code>","text":"<p>Get pixels from a raster using the get_indices2 function for filtering.</p> <p>This function extracts pixel values from an array based on indices that don't match the mask values. It works with both 2D and 3D arrays and is particularly useful for filtering out specific values (like NoData values) from an array.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>Array of raster data in the form [y][x] for 2D arrays or [bands][y][x] for 3D arrays.</p> required <code>mask</code> <code>Optional[List[Union[int, float, number]]]</code> <p>List of values to exclude from the result. - If None, returns all pixels. - If list with values, returns pixels not matching those values. See get_indices2 for more details on mask behavior.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array of filtered pixel values. - For 2D input: 1D array of values - For 3D input: 2D array with bands as rows and filtered pixels as columns</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mask contains more than two values.</p> <code>ValueError</code> <p>If the input array dimensions are not supported (must be 2D or 3D).</p> <p>Examples:</p> <ul> <li>Import numpy <pre><code>&gt;&gt;&gt; import numpy as np\n</code></pre></li> <li>2D array example <pre><code>&gt;&gt;&gt; arr_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n</code></pre></li> <li>Get all pixels <pre><code>&gt;&gt;&gt; pixels = get_pixels2(arr_2d, None)\n&gt;&gt;&gt; len(pixels)\n9\n</code></pre></li> <li>Filter out pixels with value 5 <pre><code>&gt;&gt;&gt; pixels = get_pixels2(arr_2d, [5])\n&gt;&gt;&gt; sorted(pixels) #doctest: +SKIP\n[1, 2, 3, 4, 6, 7, 8, 9]\n</code></pre></li> <li>3D array example <pre><code>&gt;&gt;&gt; arr_3d = np.array(\n...     [\n...         [[1, 2, 3], [4, 5, 6]],\n...         [[10, 20, 30], [40, 50, 60]]\n...     ]\n... )\n</code></pre></li> <li>Filter out pixels with value 5 and 50 <pre><code>&gt;&gt;&gt; pixels = get_pixels2(arr_3d, [5, 50])\n&gt;&gt;&gt; pixels.shape\n(2, 5)\n&gt;&gt;&gt; pixels[0]  # First band values #doctest: +SKIP\narray([1, 2, 3, 4, 6])\n&gt;&gt;&gt; pixels[1]  # Second band values #doctest: +SKIP\narray([10, 20, 30, 40, 60])\n</code></pre></li> </ul> Source code in <code>src/hpc/indexing.py</code> <pre><code>def get_pixels2(\n    arr: np.ndarray, mask: Optional[List[Union[int, float, np.number]]] = None\n) -&gt; np.ndarray:\n    \"\"\"Get pixels from a raster using the get_indices2 function for filtering.\n\n    This function extracts pixel values from an array based on indices that don't match the mask values.\n    It works with both 2D and 3D arrays and is particularly useful for filtering out specific values\n    (like NoData values) from an array.\n\n    Args:\n        arr: Array of raster data in the form [y][x] for 2D arrays or [bands][y][x] for 3D arrays.\n        mask: List of values to exclude from the result.\n            - If None, returns all pixels.\n            - If list with values, returns pixels not matching those values.\n            See get_indices2 for more details on mask behavior.\n\n    Returns:\n        np.ndarray: Array of filtered pixel values.\n            - For 2D input: 1D array of values\n            - For 3D input: 2D array with bands as rows and filtered pixels as columns\n\n    Raises:\n        ValueError: If mask contains more than two values.\n        ValueError: If the input array dimensions are not supported (must be 2D or 3D).\n\n    Examples:\n        - Import numpy\n        ```python\n        &gt;&gt;&gt; import numpy as np\n\n        ```\n        - 2D array example\n        ```python\n        &gt;&gt;&gt; arr_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        ```\n        - Get all pixels\n        ```python\n        &gt;&gt;&gt; pixels = get_pixels2(arr_2d, None)\n        &gt;&gt;&gt; len(pixels)\n        9\n\n        ```\n        - Filter out pixels with value 5\n        ```python\n        &gt;&gt;&gt; pixels = get_pixels2(arr_2d, [5])\n        &gt;&gt;&gt; sorted(pixels) #doctest: +SKIP\n        [1, 2, 3, 4, 6, 7, 8, 9]\n\n        ```\n        - 3D array example\n        ```python\n        &gt;&gt;&gt; arr_3d = np.array(\n        ...     [\n        ...         [[1, 2, 3], [4, 5, 6]],\n        ...         [[10, 20, 30], [40, 50, 60]]\n        ...     ]\n        ... )\n\n        ```\n        - Filter out pixels with value 5 and 50\n        ```python\n        &gt;&gt;&gt; pixels = get_pixels2(arr_3d, [5, 50])\n        &gt;&gt;&gt; pixels.shape\n        (2, 5)\n        &gt;&gt;&gt; pixels[0]  # First band values #doctest: +SKIP\n        array([1, 2, 3, 4, 6])\n        &gt;&gt;&gt; pixels[1]  # Second band values #doctest: +SKIP\n        array([10, 20, 30, 40, 60])\n\n        ```\n    \"\"\"\n    if arr.ndim == 2:\n        ind = get_indices2(arr, mask)\n        fn = lambda x: arr[x[0], x[1]]\n        values = np.fromiter(map(fn, ind), dtype=arr.dtype)\n    else:\n        ind = get_indices2(arr[0, :, :], mask)\n        fn = lambda x: arr[:, x[0], x[1]]\n        values = list(map(fn, ind))\n        values = np.array(values, dtype=arr.dtype)\n        values = values.transpose()\n\n    return values\n</code></pre>"},{"location":"api/indexing/#hpc.indexing.locate_values","title":"<code>locate_values(values, grid_x, grid_y)</code>","text":"<p>Locate coordinates in a grid by finding the closest grid points.</p> <p>This function takes a set of (x,y) coordinates and finds the closest matching indices in the provided grid_x and grid_y arrays. It's particularly useful for mapping point data to grid cells in spatial analysis and interpolation tasks.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>Array with shape (n, 2), where each row contains [x, y] coordinates to locate. Example: <pre><code>array([[454795, 503143],\n       [443847, 481850],\n       [454044, 481189]])\n</code></pre></p> required <code>grid_x</code> <code>ndarray</code> <p>Array of x-coordinates (west to east) to search within. These are typically the x-coordinates of a grid.</p> required <code>grid_y</code> <code>ndarray</code> <p>Array of y-coordinates (north to south) to search within. These are typically the y-coordinates of a grid.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array with shape (n, 2) containing the [row, col] indices of the closest grid points to each input coordinate. Example: <pre><code>array([[ 5,  4],\n       [ 2,  9],\n       [ 5,  9]])\n</code></pre></p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If values array doesn't have shape (n, 2).</p> <code>ValueError</code> <p>If grid_x or grid_y are empty arrays.</p> <p>Examples:</p> <ul> <li>Import numpy <pre><code>&gt;&gt;&gt; import numpy as np\n</code></pre></li> <li>Create sample coordinates to locate <pre><code>&gt;&gt;&gt; coords = np.array([[10, 20], [30, 40], [50, 60]])\n</code></pre></li> <li>Create grid coordinates <pre><code>&gt;&gt;&gt; grid_x = np.array([0, 10, 20, 30, 40, 50])\n&gt;&gt;&gt; grid_y = np.array([0, 20, 40, 60, 80])\n</code></pre></li> <li>Find the closest grid indices <pre><code>&gt;&gt;&gt; indices = locate_values(coords, grid_x, grid_y)\n&gt;&gt;&gt; print(indices)\n[[1 1]\n [3 2]\n [5 3]]\n</code></pre></li> <li>Verify the first coordinate [10, 20] maps to grid_x[1]=10, grid_y[1]=20 <pre><code>&gt;&gt;&gt; grid_x[indices[0, 0]], grid_y[indices[0, 1]]\n(np.int64(10), np.int64(20))\n</code></pre></li> <li>Verify the second coordinate [30, 40] maps to grid_x[3]=30, grid_y[2]=40 <pre><code>&gt;&gt;&gt; grid_x[indices[1, 0]], grid_y[indices[1, 1]]\n(np.int64(30), np.int64(40))\n</code></pre></li> <li>Verify the third coordinate [50, 60] maps to grid_x[5]=50, grid_y[3]=60 <pre><code>&gt;&gt;&gt; grid_x[indices[2, 0]], grid_y[indices[2, 1]]\n(np.int64(50), np.int64(60))\n</code></pre></li> </ul> Source code in <code>src/hpc/indexing.py</code> <pre><code>def locate_values(\n    values: np.ndarray, grid_x: np.ndarray, grid_y: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Locate coordinates in a grid by finding the closest grid points.\n\n    This function takes a set of (x,y) coordinates and finds the closest matching indices\n    in the provided grid_x and grid_y arrays. It's particularly useful for mapping point\n    data to grid cells in spatial analysis and interpolation tasks.\n\n    Args:\n        values: Array with shape (n, 2), where each row contains [x, y] coordinates to locate.\n            Example:\n            ```\n            array([[454795, 503143],\n                   [443847, 481850],\n                   [454044, 481189]])\n            ```\n        grid_x: Array of x-coordinates (west to east) to search within.\n            These are typically the x-coordinates of a grid.\n        grid_y: Array of y-coordinates (north to south) to search within.\n            These are typically the y-coordinates of a grid.\n\n    Returns:\n        np.ndarray: Array with shape (n, 2) containing the [row, col] indices of the\n            closest grid points to each input coordinate.\n            Example:\n            ```\n            array([[ 5,  4],\n                   [ 2,  9],\n                   [ 5,  9]])\n            ```\n\n    Raises:\n        ValueError: If values array doesn't have shape (n, 2).\n        ValueError: If grid_x or grid_y are empty arrays.\n\n    Examples:\n        - Import numpy\n        ```python\n        &gt;&gt;&gt; import numpy as np\n\n        ```\n        - Create sample coordinates to locate\n        ```python\n        &gt;&gt;&gt; coords = np.array([[10, 20], [30, 40], [50, 60]])\n\n        ```\n        - Create grid coordinates\n        ```python\n        &gt;&gt;&gt; grid_x = np.array([0, 10, 20, 30, 40, 50])\n        &gt;&gt;&gt; grid_y = np.array([0, 20, 40, 60, 80])\n\n        ```\n        - Find the closest grid indices\n        ```python\n        &gt;&gt;&gt; indices = locate_values(coords, grid_x, grid_y)\n        &gt;&gt;&gt; print(indices)\n        [[1 1]\n         [3 2]\n         [5 3]]\n\n        ```\n        - Verify the first coordinate [10, 20] maps to grid_x[1]=10, grid_y[1]=20\n        ```python\n        &gt;&gt;&gt; grid_x[indices[0, 0]], grid_y[indices[0, 1]]\n        (np.int64(10), np.int64(20))\n\n        ```\n        - Verify the second coordinate [30, 40] maps to grid_x[3]=30, grid_y[2]=40\n        ```python\n        &gt;&gt;&gt; grid_x[indices[1, 0]], grid_y[indices[1, 1]]\n        (np.int64(30), np.int64(40))\n\n        ```\n        - Verify the third coordinate [50, 60] maps to grid_x[5]=50, grid_y[3]=60\n        ```python\n        &gt;&gt;&gt; grid_x[indices[2, 0]], grid_y[indices[2, 1]]\n        (np.int64(50), np.int64(60))\n\n        ```\n    \"\"\"\n    # Validate inputs\n    if len(grid_x) == 0:\n        raise ValueError(\"grid_x cannot be empty\")\n    if len(grid_y) == 0:\n        raise ValueError(\"grid_y cannot be empty\")\n\n    # Handle empty values array\n    if len(values) == 0:\n        return np.zeros((0, 2), dtype=int)\n\n    # Validate values shape\n    if values.ndim != 2 or values.shape[1] != 2:\n        raise ValueError(f\"values must have shape (n, 2), got {values.shape}\")\n\n    def find(point_i):\n        x_ind = np.abs(point_i[0] - grid_x).argmin()\n        y_ind = np.abs(point_i[1] - grid_y).argmin()\n        return x_ind, y_ind\n\n    indices = np.array(list(map(find, values)))\n\n    return indices\n</code></pre>"}]}